#include "stm32f1xx.h"
int i=0 ;
void TIM1_conf (void)
{
 TIM1->PSC = 7; // divide clock by 7
 TIM1->ARR = 1000; // set timer max as 255
 TIM1->CCR1 =0; // set the capture compare mode value as 0
 TIM1->EGR |=(1<<0); // set UG bit 1 or enable update generation
 TIM1->CR1 |= (1<<0); // enable counter
 TIM1->CCMR2 |= ((1<<11)|(1<<14)|(1<<13)); // set the pwm mode for channel 4
 TIM1->CCMR2 &= ~((1<<12)); // set the pwm mode and enable preload for the timer
 TIM1->CCER |= (1<<4); // enable capture compare for channel 4
}
void delay_us (int us) // set delay in ms
{
 TIM1->CNT = 0;
 while(TIM1->CNT < us); // limit max counter value at 1000 tiks
}
void delay_ms (int ms) // set delay in milli seconds
{
 for(int i=0;i<ms;i++)
 delay_us(1000);
}
int main (void)
{
    RCC->APB2ENR |= ((1<<2)|(1<<0)|(1<<11)); //enable timer 1, clock for port A and enable alternate function input output
    GPIOA->CRH |= ((1 << 15)|(0 << 14)); // set A11 in output mode and alternate function push pull
    GPIOA->CRH |= ((1<<13)|(1<<12)); // set output frequency max
    GPIOA->CRH &= ~((1 << 5)|(1<<4)); // set a9 as input mode and input mode push pull
    GPIOA->CRH |= ((0<<6)|(1<<7));
    TIM1_conf();
    while(1)
    {
    	  if (GPIOA->IDR & (1<<9)) //read the value in idr register at pin 9
    	  {
    	   delay_ms(100); // debounce
    	   for(i=0;i<255;i++)
    	   {
    		if (GPIOA->IDR & (1<<9))
    	    {
    		 delay_ms(100); //debounce
		     break;
    	    }
    		TIM1->CCR4 = i; //create pwm
    		delay_ms(10);
    	   }
    	   if (GPIOA->IDR & (1<<9))
    	   {
    		delay_ms(100);
    		break;
    	   }
    	   for(i=255;i>=0;i--)
    	   {
    		if (GPIOA->IDR & (1<<9))
    		{
		     delay_ms(100);
    		 break;
    		}
    		TIM1->CCR4 = i;
    		delay_ms(10);
    	   }
    	  }
    	  else
		  {
		   TIM1->CCR4 = i; //keep the i value and blink
		   delay_ms(1000);
		   TIM1->CCR4 = 0;
		   delay_ms(1000);
		  }
    }
}
